using System.Reflection;
using HelperExtensions;
using SqlCommands.Attributes;
using SqlCommands.Commands;
using SqlCommands.Metadata;
using System.Text;

namespace SqlCommands.Factories;

public abstract class SqlCommandFactoryBase
{
    #region Protected Properties

    /// <summary>
    /// Gets the SQL clause used to define an auto-incrementing column.
    /// </summary>
    protected virtual string AutoIncrementFlag { get; } = "GENERATED BY DEFAULT AS IDENTITY";

    /// <summary>
    /// Gets a mapping of .NET types to their corresponding SQL data types.
    /// </summary>
    protected virtual Dictionary<Type, string> DataTypes { get; } = new()
    {
        { typeof(int), "INT" },
        { typeof(int?), "INT" },
        { typeof(long), "BIGINT" },
        { typeof(long?), "BIGINT" },
        { typeof(short), "SMALLINT" },
        { typeof(short?), "SMALLINT" },
        { typeof(byte), "TINYINT" },
        { typeof(byte?), "TINYINT" },
        { typeof(bool), "BIT" },
        { typeof(bool?), "BIT" },
        { typeof(decimal), "DECIMAL(18, 2)" },
        { typeof(decimal?), "DECIMAL(18, 2)" },
        { typeof(double), "FLOAT" },
        { typeof(double?), "FLOAT" },
        { typeof(float), "REAL" },
        { typeof(float?), "REAL" },
        { typeof(DateTime), "DATETIME" },
        { typeof(DateTime?), "DATETIME" },
        { typeof(DateTimeOffset), "DATETIMEOFFSET" },
        { typeof(DateTimeOffset?), "DATETIMEOFFSET" },
        { typeof(TimeSpan), "TIME" },
        { typeof(TimeSpan?), "TIME" },
        { typeof(Guid), "UNIQUEIDENTIFIER" },
        { typeof(Guid?), "UNIQUEIDENTIFIER" },
        { typeof(string), "NVARCHAR(MAX)" },
        { typeof(char), "NCHAR(1)" },
        { typeof(char?), "NCHAR(1)" },
        { typeof(Enum), "INT" }
    };

    /// <summary>
    /// Gets the prefix used to denote parameters in SQL queries.
    /// </summary>
    protected virtual string ParameterPrefix { get; } = "@";

    #endregion

    #region Public Methods

    #region CreateDeleteCommand
    /// <summary>
    /// Creates a SQL DELETE command for the specified entity type, with optional filtering criteria.
    /// </summary>
    /// <remarks>The generated DELETE command includes a WHERE clause based on the provided <paramref
    /// name="data"/> and/or <paramref name="filter"/>. If <paramref name="checkPrimaryKeyOnly"/> is <see
    /// langword="true"/>, only primary key columns are used for matching. Columns marked with <see
    /// cref="IgnoreRule.DeleteAlways"/> are excluded from the WHERE clause.</remarks>
    /// <typeparam name="T">The type of the entity for which the DELETE command is being created.</typeparam>
    /// <param name="data">An instance of the entity containing values to match against the primary key or other columns.  If <paramref
    /// name="data"/> is null, <paramref name="filter"/> must be provided.</param>
    /// <param name="filter">An optional <see cref="SqlFilter"/> object specifying additional filtering criteria for the DELETE operation. If
    /// <paramref name="filter"/> is null, <paramref name="data"/> must be provided.</param>
    /// <param name="checkPrimaryKeyOnly">A boolean value indicating whether to restrict the DELETE operation to primary key columns only. If <see
    /// langword="true"/>, only primary key columns are considered for matching; otherwise, all columns in the entity
    /// are considered.</param>
    /// <returns>A <see cref="SqlCommand"/> object representing the DELETE command, including the SQL statement and any
    /// associated parameters.</returns>
    /// <exception cref="ArgumentNullException">Thrown if both <paramref name="data"/> and <paramref name="filter"/> are null, as this would result in deleting
    /// all records.</exception>
    /// <exception cref="InvalidOperationException">Thrown if no primary key is defined and no filter criteria are specified, as this would result in deleting all
    /// records.</exception>
    public virtual SqlCommand CreateDeleteCommand<T>(T data = default, SqlFilter filter = null, bool checkPrimaryKeyOnly = true)
    {
        if (data is null && filter is null)
            throw new ArgumentNullException(nameof(data), $"Either '{nameof(data)}' or '{nameof(filter)}' must be provided to avoid deleting all records.");

        ClassMetadata classMetadata = ClassMetadataCache.GetClassMetadata(typeof(T));

        StringBuilder whereClause = new();
        List<SqlParameter> parameters = new(classMetadata.PropertiesMetadata.Length);

        if (filter is not null)
        {
            whereClause.Append(filter.Text, " AND ");
            parameters.AddRange(filter.Parameters);
        }

        foreach (PropertyMetadata propertyMetadata in classMetadata.PropertiesMetadata)
        {
            PropertyInfo propertyInfo = propertyMetadata.PropertyInfo;
            SqlColumnAttribute columnAttribute = propertyMetadata.ColumnAttribute;

            if (columnAttribute.IgnoreRules.HasFlag(IgnoreRule.DeleteAlways)
                || !columnAttribute.Expression.IsNullOrWhiteSpace()
                || checkPrimaryKeyOnly && !columnAttribute.IsPrimaryKey)
                continue;
            
            string columnName = QuoteIdentifier(propertyMetadata.ColumnName);

            if (propertyInfo.GetValueOrDefault(data) is { } columnValue)
            {
                whereClause.Append(columnName, " = ", ParameterPrefix, propertyInfo.Name, " AND ");
                parameters.Add(new($"{ParameterPrefix}{propertyInfo.Name}", columnValue));
            }
            else if (!columnAttribute.IgnoreRules.HasFlag(IgnoreRule.DeleteIfNull))
                whereClause.Append(columnName, " IS NULL AND ");
        }

        if (whereClause.Length == 0)
            throw new InvalidOperationException("No primary key defined and no filter specified for the delete operation. This would result in deleting all records.");

        whereClause.Length -= 5; // Remove last " AND "

        StringBuilder commandText = new();
        commandText.Append("DELETE FROM ", QuoteIdentifier(classMetadata.TableName), " WHERE ", whereClause);

        return new(commandText.ToString(), parameters.ToArray());
    }
    #endregion

    #region CreateDropTableCommand
    /// <summary>
    /// Creates a SQL command to drop a table with optional conditions and constraints.
    /// </summary>
    /// <remarks>The generated SQL command will include optional clauses based on the <paramref
    /// name="ignoreIfNotExists"/> and <paramref name="mode"/> parameters. Use caution when using <see
    /// cref="DropTableMode.Cascade"/> as it will drop all dependent objects.</remarks>
    /// <param name="tableName">The name of the table to be dropped. This value must not be null or empty.</param>
    /// <param name="ignoreIfNotExists">A value indicating whether the command should include the "IF EXISTS" clause to avoid errors if the table does
    /// not exist. If <see langword="true"/>, the "IF EXISTS" clause is included; otherwise, it is omitted. The default
    /// value is <see langword="true"/>.</param>
    /// <param name="mode">Specifies the drop mode to use, such as cascading or restricting dependent objects. The default value is <see
    /// cref="DropTableMode.Unsafe"/>.</param>
    /// <returns>A <see cref="SqlCommand"/> object representing the SQL command to drop the specified table.</returns>
    public virtual SqlCommand CreateDropTableCommand(string tableName, bool ignoreIfNotExists = true, DropTableMode mode = DropTableMode.Unsafe)
    {
        string ignoreIfNotExistsText = ignoreIfNotExists ? "IF EXISTS " : string.Empty;
        string modeText = mode switch
        {
            DropTableMode.Cascade => " CASCADE",
            DropTableMode.Restrict => " RESTRICT",
            _ => string.Empty,
        };

        return new($"DROP TABLE {ignoreIfNotExistsText}{QuoteIdentifier(tableName)}{modeText}", []);
    }
    #endregion

    #region CreateInsertCommand
    /// <summary>
    /// Creates a SQL <c>INSERT</c> command for the specified data object.
    /// </summary>
    /// <remarks>This method generates an <c>INSERT</c> statement based on the metadata of the specified type
    /// <typeparamref name="T"/>. The metadata is retrieved from the <see cref="ClassMetadataCache"/> and may include
    /// property-level attributes such as <see cref="SqlColumnAttribute"/> to define column mappings and rules. <para>
    /// Properties marked with <see cref="IgnoreRule.InsertAlways"/> or with a non-empty <c>Expression</c> in their 
    /// <see cref="SqlColumnAttribute"/> are excluded from the <c>INSERT</c> statement. If a property value is <see
    /// langword="null"/>  and the <see cref="IgnoreRule.InsertIfNull"/> flag is not set, the column will be explicitly
    /// set to <c>NULL</c>. </para> <para> If no valid properties are found for the <c>INSERT</c> statement, an <see
    /// cref="InvalidOperationException"/> is thrown. </para></remarks>
    /// <typeparam name="T">The type of the data object. The type must have metadata defined using <see cref="SqlColumnAttribute"/>.</typeparam>
    /// <param name="data">The data object to insert. Cannot be <see langword="null"/>.</param>
    /// <returns>A <see cref="SqlCommand"/> object representing the <c>INSERT</c> command, with the appropriate SQL text and
    /// parameters.</returns>
    /// <exception cref="ArgumentNullException">Thrown if <paramref name="data"/> is <see langword="null"/>.</exception>
    /// <exception cref="InvalidOperationException">Thrown if no valid properties with <see cref="SqlColumnAttribute"/> are found in the specified type
    /// <typeparamref name="T"/>.</exception>
    public virtual SqlCommand CreateInsertCommand<T>(T data)
    {
        if (data is null)
            throw new ArgumentNullException(nameof(data));

        ClassMetadata classMetadata = ClassMetadataCache.GetClassMetadata(typeof(T));

        StringBuilder columns = new();
        StringBuilder values = new();
        List<SqlParameter> parameters = new(classMetadata.PropertiesMetadata.Length);

        foreach (PropertyMetadata propertyMetadata in classMetadata.PropertiesMetadata)
        {
            PropertyInfo propertyInfo = propertyMetadata.PropertyInfo;
            SqlColumnAttribute columnAttribute = propertyMetadata.ColumnAttribute;

            if (!columnAttribute.Expression.IsNullOrWhiteSpace()
                || columnAttribute.IgnoreRules.HasFlag(IgnoreRule.InsertAlways))
                continue;

            string columnName = QuoteIdentifier(propertyMetadata.ColumnName);

            if (propertyInfo.GetValueOrDefault(data) is { } columnValue)
            {
                columns.Append(columnName, ", ");
                values.Append(ParameterPrefix, propertyInfo.Name, ", ");
                parameters.Add(new($"{ParameterPrefix}{propertyInfo.Name}", columnValue));
            }
            else if (!columnAttribute.IgnoreRules.HasFlag(IgnoreRule.InsertIfNull))
            {
                columns.Append(columnName, ", ");
                values.Append("NULL, ");
            }
        }

        if (columns.Length == 0)
            throw new InvalidOperationException($"No valid properties with '{nameof(SqlColumnAttribute)}' found in '{classMetadata.ClassType.Name}'.");

        // Removes last ", "
        columns.Length -= 2;
        values.Length -= 2;

        StringBuilder commandText = new();
        commandText.Append("INSERT INTO ", QuoteIdentifier(classMetadata.TableName), " (", columns, ") VALUES (", values, ");");

        return new(commandText.ToString(), parameters.ToArray());
    }
    #endregion

    #region CreateNewTableCommand
    /// <summary>
    /// Creates a new <see cref="SqlCommand"/> that defines a SQL statement for creating a table based on the specified
    /// data type's metadata.
    /// </summary>
    /// <remarks>The method inspects the metadata of the provided data type to generate the SQL command.
    /// The method will throw an exception if no valid properties are found or if the data type contains
    /// unsupported property types.</remarks>
    /// <param name="dataType">The <see cref="Type"/> representing the data model for which the table creation command will be generated.</param>
    /// <returns>A <see cref="SqlCommand"/> containing the SQL statement to create a table that matches the structure of the
    /// specified data type.</returns>
    /// <exception cref="InvalidOperationException">Thrown if the specified <paramref name="dataType"/> does not contain any valid properties,
    /// or if a property type is not supported by the database.</exception>
    public virtual SqlCommand CreateNewTableCommand(Type dataType)
    {
        ClassMetadata classMetadata = ClassMetadataCache.GetClassMetadata(dataType);
        StringBuilder columnsText = new();

        foreach (PropertyMetadata propertyMetadata in classMetadata.PropertiesMetadata)
        {
            PropertyInfo propertyInfo = propertyMetadata.PropertyInfo;
            SqlColumnAttribute columnAttribute = propertyMetadata.ColumnAttribute;

            if (!columnAttribute.Expression.IsNullOrWhiteSpace())
                continue;

            string columnName = QuoteIdentifier(columnAttribute.Name ?? propertyInfo.Name);
            string columnType = columnAttribute.Type ?? GetSqlType(propertyInfo.PropertyType);

            columnsText.Append(columnName, " ", columnType);

            if (columnAttribute.IsPrimaryKey)
                columnsText.Append(" PRIMARY KEY");

            if (columnAttribute.IsAutoIncrement)
                columnsText.Append(" ", AutoIncrementFlag);

            columnsText.Append(", ");
        }

        if (columnsText.Length == 0)
            throw new InvalidOperationException($"No valid properties with '{nameof(SqlColumnAttribute)}' found in '{classMetadata.ClassType.Name}'.");

        columnsText.Length -= 2; // Removes last ", "
        return new($"CREATE TABLE {QuoteIdentifier(classMetadata.TableName)} ({columnsText})", []);

        #region Inner Methods

        #region GetSqlType
        // Convert the current Type into a SQL data type string.
        string GetSqlType(Type type)
        {
            if (type.IsEnum && DataTypes.TryGetValue(typeof(int), out string sqlType)
                || DataTypes.TryGetValue(type, out sqlType))
                return sqlType;

            throw new InvalidOperationException($"The '{type}' type is not supported by the current database.");
        }
        #endregion

        #endregion
    }
    #endregion

    #region CreateSelectCommand
    /// <summary>
    /// Creates a SQL <c>SELECT</c> command for querying data from a database table based on the specified type and optional parameters.
    /// </summary>
    /// <remarks>This method dynamically constructs a SQL <c>SELECT</c> query based on the metadata of the specified
    /// type <typeparamref name="T"/>. The query includes all columns (except the ones mapped by <see cref="SqlIgnoreAttribute"/>) and applies
    /// filtering conditions based on the provided <paramref name="data"/> and <paramref name="filter"/>. Pagination is
    /// supported through the <paramref name="offset"/> and <paramref name="maxResults"/> parameters.</remarks>
    /// <typeparam name="T">The type of the entity to query. The type must have metadata defined using <see cref="SqlColumnAttribute"/> and
    /// <see cref="SqlTableAttribute"/>.</typeparam>
    /// <param name="data">An optional instance of the entity type <typeparamref name="T"/>. If provided, its property values are used to
    /// generate additional filtering conditions.</param>
    /// <param name="distinct">A value indicating whether the <c>SELECT</c> query should include the <c>DISTINCT</c> keyword. <see langword="true"/> to
    /// include <c>DISTINCT</c>; otherwise, <see langword="false"/>.</param>
    /// <param name="filter">An optional <see cref="SqlFilter"/> object that specifies additional filtering conditions for the query.</param>
    /// <param name="offset">The number of rows to skip before starting to return rows. Must be non-negative.</param>
    /// <param name="maxResults">The maximum number of rows to return. Specify -1 to return all rows after the offset.</param>
    /// <returns>A <see cref="SqlCommand"/> object representing the constructed SQL <c>SELECT</c> query, including any parameters for
    /// filtering.</returns>
    /// <exception cref="InvalidOperationException">Thrown if no eligible properties are found in the specified type <typeparamref
    /// name="T"/>.</exception>
    public virtual SqlCommand CreateSelectCommand<T>(T data = default, bool distinct = false, SqlFilter filter = null, int offset = 0, int maxResults = -1)
    {
        ValidateSelectPaginationInfo(offset, maxResults);

        ClassMetadata classMetadata = ClassMetadataCache.GetClassMetadata(typeof(T));

        StringBuilder columns = new();
        StringBuilder whereClause = new();
        List<SqlParameter> parameters = new(classMetadata.PropertiesMetadata.Length);

        if (filter is not null)
        {
            whereClause.Append(filter.Text, " AND ");
            parameters.AddRange(filter.Parameters);
        }

        foreach (PropertyMetadata propertyMetadata in classMetadata.PropertiesMetadata)
        {
            PropertyInfo propertyInfo = propertyMetadata.PropertyInfo;
            SqlColumnAttribute columnAttribute = propertyMetadata.ColumnAttribute;

            if (columnAttribute.IgnoreRules.HasFlag(IgnoreRule.SelectAlways))
                continue;

            string columnName = QuoteIdentifier(propertyMetadata.ColumnName);
            string propertyName = QuoteIdentifier(propertyInfo.Name);

            columns.Append(columnAttribute.Expression ?? columnName, " AS ", propertyName, ", ");

            if (propertyInfo.GetValueOrDefault(data) is { } columnValue)
            {
                whereClause.Append(propertyName, " = ", ParameterPrefix, propertyInfo.Name, " AND ");
                parameters.Add(new($"{ParameterPrefix}{propertyInfo.Name}", columnValue));
            }
            else if (!columnAttribute.IgnoreRules.HasFlag(IgnoreRule.SelectIfNull))
                whereClause.Append(columnName, " IS NULL AND ");
        }

        if (columns.Length == 0)
            throw new InvalidOperationException($"No properties with '{nameof(SqlColumnAttribute)}' found in '{classMetadata.ClassType.Name}'.");

        columns.Length -= 2; // Removes last ", "

        SqlTableAttribute tableAttribute = classMetadata.TableAttribute;
        StringBuilder commandText = new();

        commandText.Append("SELECT ");

        if (distinct)
            commandText.Append("DISTINCT ");

        commandText.Append(columns, " FROM ", QuoteIdentifier(classMetadata.TableName));

        if (whereClause.Length > 0)
        {
            whereClause.Length -= 5; // Remove last " AND "
            commandText.Append(" WHERE ", whereClause);
        }

        if (!tableAttribute.GroupBy.IsNullOrWhiteSpace())
            commandText.Append(" GROUP BY ", tableAttribute.GroupBy);

        if (!tableAttribute.Having.IsNullOrWhiteSpace())
            commandText.Append(" HAVING ", tableAttribute.Having);

        if (!tableAttribute.OrderBy.IsNullOrWhiteSpace())
            commandText.Append(" ORDER BY ", tableAttribute.OrderBy);

        AppendSelectPaginationClause(commandText, tableAttribute, offset, maxResults);

        return new(commandText.ToString(), parameters.ToArray());
    }
    #endregion

    #region CreateUpdateCommand
    /// <summary>
    /// Creates an <see cref="SqlCommand"/> to perform an update operation on a database table based on the specified
    /// data object and optional filter criteria.
    /// </summary>
    /// <remarks>This method generates an SQL <c>UPDATE</c> statement dynamically based on the metadata of the
    /// specified data type. All properties (except the ones marked with <see cref="SqlColumnAttribute"/>) are used to construct the <c>SET</c>
    /// clause, and primary key properties or the provided filter are used to construct the WHERE clause. If a property
    /// value is null, its behavior depends on the <see cref="IgnoreRule"/> specified in the <see
    /// cref="SqlColumnAttribute"/>.</remarks>
    /// <typeparam name="T">The type of the data object representing the entity to be updated. The type may have metadata defined using
    /// <see cref="SqlColumnAttribute"/> for its properties.</typeparam>
    /// <param name="data">The data object containing the values to update.</param>
    /// <param name="filter">An optional <see cref="SqlFilter"/> object specifying additional conditions for the update operation. If
    /// provided, the filter is appended to the <c>WHERE</c> clause.</param>
    /// <returns>An <see cref="SqlCommand"/> object representing the update operation. The command includes the SQL statement and
    /// the associated parameters.</returns>
    /// <exception cref="InvalidOperationException">Thrown if no eligible properties are found in the data object, or if no primary key
    /// is defined and no filter is specified, which would result in updating all records.</exception>
    public virtual SqlCommand CreateUpdateCommand<T>(T data, SqlFilter filter = null)
    {
        ClassMetadata classMetadata = ClassMetadataCache.GetClassMetadata(typeof(T));

        StringBuilder setClause = new();
        StringBuilder whereClause = new();
        List<SqlParameter> parameters = new(classMetadata.PropertiesMetadata.Length);

        if (filter is not null)
        {
            whereClause.Append(filter.Text, " AND ");
            parameters.AddRange(filter.Parameters);
        }

        foreach (PropertyMetadata propertyMetadata in classMetadata.PropertiesMetadata)
        {
            PropertyInfo propertyInfo = propertyMetadata.PropertyInfo;
            SqlColumnAttribute columnAttribute = propertyMetadata.ColumnAttribute;

            if (!columnAttribute.Expression.IsNullOrWhiteSpace()
                || columnAttribute.IgnoreRules.HasFlag(IgnoreRule.UpdateAlways))
                continue;

            string columnName = QuoteIdentifier(propertyMetadata.ColumnName);

            if (propertyInfo.GetValueOrDefault(data) is { } columnValue)
            {
                if (columnAttribute.IsPrimaryKey)
                    whereClause.Append(columnName, " = ", ParameterPrefix, propertyInfo.Name, " AND ");
                else
                    setClause.Append(columnName, " = ", ParameterPrefix, propertyInfo.Name, ", ");

                parameters.Add(new($"{ParameterPrefix}{propertyInfo.Name}", columnValue));
            }
            else if (!columnAttribute.IgnoreRules.HasFlag(IgnoreRule.UpdateIfNull))
                setClause.Append(columnName, " = NULL, ");
        }

        if (setClause.Length == 0)
            throw new InvalidOperationException($"No properties with '{nameof(SqlColumnAttribute)}' found in '{classMetadata.ClassType.Name}'.");

        if (whereClause.Length == 0)
            throw new InvalidOperationException("No primary key defined and no filter specified for the update operation. This would result in updating all records.");

        setClause.Length -= 2; // Removes last ", "

        StringBuilder commandText = new();
        commandText.Append("UPDATE ", QuoteIdentifier(classMetadata.TableName), " SET ", setClause);

        if (whereClause.Length > 0)
        {
            whereClause.Length -= 5; // Remove last " AND "
            commandText.Append(" WHERE ", whereClause);
        }

        return new(commandText.ToString(), parameters.ToArray());
    }
    #endregion

    #region CreateUpsertCommand
    /// <summary>
    /// Creates a SQL command to perform an upsert (merge) operation for the specified data entity.
    /// </summary>
    /// <remarks>The upsert operation merges the specified data entity into the target table. If a matching
    /// row exists based on the primary key, the row is updated; otherwise, a new row is inserted. The method uses
    /// metadata to determine the table name, primary key, and columns to include in the operation.</remarks>
    /// <typeparam name="T">The type of the data entity. The type must have metadata defined for its properties and table mapping.</typeparam>
    /// <param name="data">The data entity to be upserted. Cannot be <see langword="null"/>.</param>
    /// <returns>A <see cref="SqlCommand"/> configured to execute the upsert operation. The command includes the necessary SQL
    /// text and parameters.</returns>
    /// <exception cref="ArgumentNullException">Thrown if <paramref name="data"/> is <see langword="null"/>.</exception>
    /// <exception cref="InvalidOperationException">Thrown if no eligible primary key column is found in the metadata for the specified type, or if no columns are
    /// available to be set during the operation.</exception>
    public virtual SqlCommand CreateUpsertCommand<T>(T data)
    {
        if (data is null)
            throw new ArgumentNullException(nameof(data));

        ClassMetadata classMetadata = ClassMetadataCache.GetClassMetadata(typeof(T));

        StringBuilder onClause = new();
        StringBuilder setClause = new();
        StringBuilder insertClause = new();
        StringBuilder valuesClause = new();

        foreach (PropertyMetadata propertyMetadata in classMetadata.PropertiesMetadata)
        {
            PropertyInfo propertyInfo = propertyMetadata.PropertyInfo;
            SqlColumnAttribute columnAttribute = propertyMetadata.ColumnAttribute;

            if (columnAttribute.IgnoreRules.HasFlag(IgnoreRule.UpsertAlways)
                || !columnAttribute.Expression.IsNullOrWhiteSpace()
                || (!propertyInfo.TryGetValue(data, out object columnValue) || columnValue is null)
                && columnAttribute.IgnoreRules.HasFlag(IgnoreRule.UpsertIfNull))
                continue;

            string columnName = QuoteIdentifier(propertyMetadata.ColumnName);

            if (columnAttribute.IsPrimaryKey)
                if (columnValue is null)
                    onClause.Append("target.", columnName, " IS NULL AND source.", columnName, " IS NULL AND ");
                else
                    onClause.Append("target.", columnName, " = source.", columnName, " AND ");
            else
                setClause.Append("target.", columnName, " = source.", columnName, ", ");

            insertClause.Append(columnName, ", ");
            valuesClause.Append("source.", columnName, ", ");
        }

        if (onClause.Length == 0)
            throw new InvalidOperationException($"No eligible primary key column found in {classMetadata.ClassType.Name}.");

        if (setClause.Length == 0)
            throw new InvalidOperationException($"No columns to be set found in {classMetadata.ClassType.Name}.");

        onClause.Length -= 5; // Removes last " AND "

        // Removes last ", "
        setClause.Length -= 2;
        insertClause.Length -= 2;
        valuesClause.Length -= 2;

        StringBuilder commandText = new();
        List<SqlParameter> parameters = new(classMetadata.PropertiesMetadata.Length);

        commandText.Append("MERGE INTO ", QuoteIdentifier(classMetadata.TableName), " AS target ");
        AppendUpsertSourceClause(data, commandText, parameters, classMetadata.PropertiesMetadata);
        commandText.Append("ON ", onClause, " WHEN MATCHED THEN UPDATE SET ", setClause, " WHEN NOT MATCHED THEN INSERT(",
            insertClause, ") VALUES(", valuesClause, ");");

        return new(commandText.ToString(), parameters.ToArray());
    }
    #endregion

    #endregion

    #region Protected Methods

    #region AppendSelectPaginationClause
    /// <summary>
    /// Appends a SQL pagination clause to the provided command text, using the specified offset and maximum number of
    /// results.
    /// </summary>
    /// <param name="commandText">The <see cref="StringBuilder"/> to which the pagination clause will be appended.</param>
    /// <param name="tableAttribute">The <see cref="SqlTableAttribute"/> containing metadata about the target table. This may influence the generated
    /// SQL.</param>
    /// <param name="offset">The number of rows to skip before starting to return rows. Must be zero or greater.</param>
    /// <param name="maxResults">The maximum number of rows to return. If zero or less, no pagination clause is appended.</param>
    protected virtual void AppendSelectPaginationClause(StringBuilder commandText, SqlTableAttribute tableAttribute, int offset, int maxResults)
    {
        if (maxResults > 0)
        {
            if (tableAttribute.OrderBy.IsNullOrWhiteSpace())
                commandText.Append(" ORDER BY (SELECT NULL)"); // ORDER BY is required when using OFFSET-FETCH.

            commandText.Append(" OFFSET ", offset, " ROWS FETCH NEXT ", maxResults, " ROWS ONLY");
        }
    }
    #endregion

    #region AppendUpsertSourceClause
    /// <summary>
    /// Appends the USING clause for an UPSERT operation to the provided SQL command text.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="data"></param>
    /// <param name="commandText"></param>
    /// <param name="parameters"></param>
    /// <param name="propertiesMetadata"></param>
    /// <exception cref="InvalidOperationException"></exception>
    protected virtual void AppendUpsertSourceClause<T>(T data, StringBuilder commandText, List<SqlParameter> parameters, PropertyMetadata[] propertiesMetadata)
    {
        StringBuilder columnsText = new();

        foreach (PropertyMetadata propertyMetadata in propertiesMetadata)
        {
            PropertyInfo propertyInfo = propertyMetadata.PropertyInfo;
            SqlColumnAttribute columnAttribute = propertyMetadata.ColumnAttribute;

            if (columnAttribute.IgnoreRules.HasFlag(IgnoreRule.UpsertAlways)
                || !columnAttribute.Expression.IsNullOrWhiteSpace())
                continue;

            if (propertyInfo.GetValueOrDefault(data) is { } columnValue)
            {
                columnsText.Append(ParameterPrefix, propertyInfo.Name, " AS ", propertyMetadata.ColumnName, ", ");
                parameters.Add(new($"{ParameterPrefix}{propertyInfo.Name}", columnValue));
            }
            else if (!columnAttribute.IgnoreRules.HasFlag(IgnoreRule.UpsertIfNull))
                columnsText.Append("NULL AS ", propertyMetadata.ColumnName, ", ");
        }

        if (columnsText.Length == 0)
            throw new InvalidOperationException($"No eligible properties with '{nameof(SqlColumnAttribute)}' found in '{typeof(T).Name}'.");

        columnsText.Length -= 2; // Removes last ", "
        commandText.Append("USING (SELECT ", columnsText, ") AS source ");
    }
    #endregion

    #region ValidateSelectPaginationInfo
    /// <summary>
    /// Validates the pagination parameters to ensure they are within acceptable ranges.
    /// </summary>
    /// <param name="offset"></param>
    /// <param name="maxResults"></param>
    /// <exception cref="ArgumentOutOfRangeException"></exception>
    protected virtual void ValidateSelectPaginationInfo(int offset, int maxResults)
    {
        if (offset < 0)
            throw new ArgumentOutOfRangeException(nameof(offset), $"'{nameof(offset)}' must be greater than or equal to zero.");

        if (offset > 0 && maxResults <= 0)
            throw new ArgumentOutOfRangeException(nameof(maxResults), $"When '{nameof(offset)}' is greater than zero, '{nameof(maxResults)}' must be greater than zero.");
    }
    #endregion

    #region QuoteIdentifier
    /// <summary>
    /// Encloses the specified identifier in double quotes to ensure it is treated as a literal identifier.
    /// </summary>
    /// <remarks>This method is typically used to escape identifiers such as table or column names to prevent
    /// conflicts with reserved keywords or invalid characters.</remarks>
    /// <param name="identifier">The identifier to be quoted.</param>
    /// <returns>A string representing the quoted identifier.</returns>
    protected virtual string QuoteIdentifier(string identifier) =>
        $"\"{identifier}\"";
    #endregion

    #endregion
}