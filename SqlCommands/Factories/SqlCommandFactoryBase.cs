using System.Reflection;
using HelperExtensions;
using SqlCommands.Attributes;
using SqlCommands.Commands;
using SqlCommands.Metadata;
using System.Text;

namespace SqlCommands.Factories;

public abstract class SqlCommandFactoryBase
{
    #region Protected Properties

    /// <summary>
    /// Gets the SQL clause used to define an auto-incrementing column.
    /// </summary>
    protected virtual string AutoIncrementFlag { get; } = "GENERATED BY DEFAULT AS IDENTITY";

    /// <summary>
    /// Gets a mapping of .NET types to their corresponding SQL data types.
    /// </summary>
    protected virtual Dictionary<Type, string> DataTypes { get; } = new()
    {
        { typeof(int), "INT" },
        { typeof(int?), "INT" },
        { typeof(long), "BIGINT" },
        { typeof(long?), "BIGINT" },
        { typeof(short), "SMALLINT" },
        { typeof(short?), "SMALLINT" },
        { typeof(byte), "TINYINT" },
        { typeof(byte?), "TINYINT" },
        { typeof(bool), "BIT" },
        { typeof(bool?), "BIT" },
        { typeof(decimal), "DECIMAL(18, 2)" },
        { typeof(decimal?), "DECIMAL(18, 2)" },
        { typeof(double), "FLOAT" },
        { typeof(double?), "FLOAT" },
        { typeof(float), "REAL" },
        { typeof(float?), "REAL" },
        { typeof(DateTime), "DATETIME" },
        { typeof(DateTime?), "DATETIME" },
        { typeof(DateTimeOffset), "DATETIMEOFFSET" },
        { typeof(DateTimeOffset?), "DATETIMEOFFSET" },
        { typeof(TimeSpan), "TIME" },
        { typeof(TimeSpan?), "TIME" },
        { typeof(Guid), "UNIQUEIDENTIFIER" },
        { typeof(Guid?), "UNIQUEIDENTIFIER" },
        { typeof(string), "NVARCHAR(MAX)" },
        { typeof(char), "NCHAR(1)" },
        { typeof(char?), "NCHAR(1)" },
        { typeof(Enum), "INT" }
    };

    #endregion

    #region Public Methods

    #region CreateDeleteCommand
    /// <summary>
    /// Generates a SQL DELETE command based on the properties of the specified class type <typeparamref name="T"/>.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="data"></param>
    /// <param name="filter"></param>
    /// <param name="checkPrimaryKeyOnly"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentNullException"></exception>
    /// <exception cref="InvalidOperationException"></exception>
    public virtual SqlCommand CreateDeleteCommand<T>(T data = default, SqlFilter filter = null, bool checkPrimaryKeyOnly = true)
    {
        if (data is null && filter is null)
            throw new ArgumentNullException(nameof(data), $"Either '{nameof(data)}' or '{nameof(filter)}' must be provided to avoid deleting all records.");

        ClassMetadata classMetadata = ClassMetadataCache.GetClassMetadata(typeof(T));

        StringBuilder whereClause = new();
        List<SqlParameter> parameters = new(classMetadata.PropertiesMetadata.Length);

        if (filter is not null)
        {
            whereClause.Append(filter.Text, " AND ");
            parameters.AddRange(filter.Parameters);
        }

        foreach (PropertyMetadata propertyMetadata in classMetadata.PropertiesMetadata)
        {
            PropertyInfo propertyInfo = propertyMetadata.PropertyInfo;
            SqlColumnAttribute columnAttribute = propertyMetadata.ColumnAttribute;

            if (columnAttribute.IgnoreRules.HasFlag(IgnoreRule.DeleteAlways)
                || !columnAttribute.Expression.IsNullOrWhiteSpace()
                || checkPrimaryKeyOnly && !columnAttribute.IsPrimaryKey)
                continue;

            if (propertyInfo.GetValueOrDefault(data) is { } columnValue)
            {
                whereClause.Append(propertyMetadata.ColumnName, " = @", propertyInfo.Name, " AND ");
                parameters.Add(new($"@{propertyInfo.Name}", columnValue));
            }
            else if (!columnAttribute.IgnoreRules.HasFlag(IgnoreRule.DeleteIfNull))
                whereClause.Append(propertyMetadata.ColumnName, " IS NULL AND ");
        }

        if (whereClause.Length == 0)
            throw new InvalidOperationException("No primary key defined and no filter specified for the delete operation. This would result in deleting all records.");

        whereClause.Length -= 5; // Remove last " AND "

        StringBuilder commandText = new();
        commandText.Append("DELETE FROM ", classMetadata.TableName, " WHERE ", whereClause);

        return new(commandText.ToString(), parameters.ToArray());
    }
    #endregion

    #region CreateDropTableCommand
    /// <summary>
    /// Generates a SQL DROP TABLE command for the specified table name.
    /// </summary>
    /// <param name="tableName"></param>
    /// <param name="ignoreIfNotExists"></param>
    /// <param name="mode"></param>
    /// <returns></returns>
    public virtual SqlCommand CreateDropTableCommand(string tableName, bool ignoreIfNotExists = true, DropTableMode mode = DropTableMode.Unsafe)
    {
        string ignoreIfNotExistsText = ignoreIfNotExists ? "IF EXISTS " : string.Empty;
        string modeText = mode switch
        {
            DropTableMode.Cascade => " CASCADE",
            DropTableMode.Restrict => " RESTRICT",
            _ => string.Empty,
        };

        return new($"DROP TABLE {ignoreIfNotExistsText}{tableName}{modeText}", []);
    }
    #endregion

    #region CreateInsertCommand
    /// <summary>
    /// Generates a SQL INSERT command based on the properties of the specified class type <typeparamref name="T"/>.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="data"></param>
    /// <returns></returns>
    /// <exception cref="InvalidOperationException"></exception>
    public virtual SqlCommand CreateInsertCommand<T>(T data)
    {
        if (data is null)
            throw new ArgumentNullException(nameof(data));

        ClassMetadata classMetadata = ClassMetadataCache.GetClassMetadata(typeof(T));

        StringBuilder columns = new();
        StringBuilder values = new();
        List<SqlParameter> parameters = new(classMetadata.PropertiesMetadata.Length);

        foreach (PropertyMetadata propertyMetadata in classMetadata.PropertiesMetadata)
        {
            PropertyInfo propertyInfo = propertyMetadata.PropertyInfo;
            SqlColumnAttribute columnAttribute = propertyMetadata.ColumnAttribute;

            if (!columnAttribute.Expression.IsNullOrWhiteSpace()
                || columnAttribute.IgnoreRules.HasFlag(IgnoreRule.InsertAlways))
                continue;

            if (propertyInfo.GetValueOrDefault(data) is { } columnValue)
            {
                columns.Append(propertyMetadata.ColumnName, ", ");
                values.Append("@", propertyInfo.Name, ", ");
                parameters.Add(new($"@{propertyInfo.Name}", columnValue));
            }
            else if (!columnAttribute.IgnoreRules.HasFlag(IgnoreRule.InsertIfNull))
            {
                columns.Append(propertyMetadata.ColumnName, ", ");
                values.Append("NULL, ");
            }
        }

        if (columns.Length == 0)
            throw new InvalidOperationException($"No valid properties with '{nameof(SqlColumnAttribute)}' found in '{classMetadata.ClassType.Name}'.");

        // Removes last ", "
        columns.Length -= 2;
        values.Length -= 2;

        StringBuilder commandText = new();
        commandText.Append("INSERT INTO ", classMetadata.TableName, " (", columns, ") VALUES (", values, ");");

        return new(commandText.ToString(), parameters.ToArray());
    }
    #endregion

    #region CreateNewTableCommand
    /// <summary>
    /// Generates a SQL CREATE TABLE command based on the properties of the specified data type.
    /// </summary>
    /// <param name="dataType"></param>
    /// <returns></returns>
    /// <exception cref="InvalidOperationException"></exception>
    public virtual SqlCommand CreateNewTableCommand(Type dataType)
    {
        ClassMetadata classMetadata = ClassMetadataCache.GetClassMetadata(dataType);
        StringBuilder columnsText = new();

        foreach (PropertyMetadata propertyMetadata in classMetadata.PropertiesMetadata)
        {
            PropertyInfo propertyInfo = propertyMetadata.PropertyInfo;
            SqlColumnAttribute columnAttribute = propertyMetadata.ColumnAttribute;

            if (!columnAttribute.Expression.IsNullOrWhiteSpace())
                continue;

            string columnName = columnAttribute.Name ?? propertyInfo.Name;
            string columnType = columnAttribute.Type ?? GetSqlType(propertyInfo.PropertyType);

            columnsText.Append(columnName, " ", columnType);

            if (columnAttribute.IsPrimaryKey)
                columnsText.Append(" PRIMARY KEY");

            if (columnAttribute.IsAutoIncrement)
                columnsText.Append(" ", AutoIncrementFlag);

            columnsText.Append(", ");
        }

        if (columnsText.Length == 0)
            throw new InvalidOperationException($"No valid properties with '{nameof(SqlColumnAttribute)}' found in '{classMetadata.ClassType.Name}'.");

        columnsText.Length -= 2; // Removes last ", "
        return new($"CREATE TABLE {classMetadata.TableName} ({columnsText})", []);

        #region Inner Methods

        #region GetSqlType
        // Convert the current Type into a SQL data type string.
        string GetSqlType(Type type)
        {
            if (type.IsEnum && DataTypes.TryGetValue(typeof(int), out string sqlType)
                || DataTypes.TryGetValue(type, out sqlType))
                return sqlType;

            throw new InvalidOperationException($"The '{type}' type is not supported by the current database.");
        }
        #endregion

        #endregion
    }
    #endregion

    #region CreateSelectCommand
    /// <summary>
    /// Generates a SQL SELECT command based on the properties of the specified class type <typeparamref name="T"/>.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="data"></param>
    /// <param name="distinct"></param>
    /// <param name="filter"></param>
    /// <param name="offset"></param>
    /// <param name="maxResults"></param>
    /// <returns></returns>
    /// <exception cref="InvalidOperationException"></exception>
    public virtual SqlCommand CreateSelectCommand<T>(T data = default, bool distinct = false, SqlFilter filter = null, int offset = 0, int maxResults = -1)
    {
        ValidateSelectPaginationInfo(offset, maxResults);

        ClassMetadata classMetadata = ClassMetadataCache.GetClassMetadata(typeof(T));

        StringBuilder columns = new();
        StringBuilder whereClause = new();
        List<SqlParameter> parameters = new(classMetadata.PropertiesMetadata.Length);

        if (filter is not null)
        {
            whereClause.Append(filter.Text, " AND ");
            parameters.AddRange(filter.Parameters);
        }

        foreach (PropertyMetadata propertyMetadata in classMetadata.PropertiesMetadata)
        {
            PropertyInfo propertyInfo = propertyMetadata.PropertyInfo;
            SqlColumnAttribute columnAttribute = propertyMetadata.ColumnAttribute;

            if (columnAttribute.IgnoreRules.HasFlag(IgnoreRule.SelectAlways))
                continue;

            columns.Append(columnAttribute.Expression ?? propertyMetadata.ColumnName, " AS ", propertyInfo.Name, ", ");

            if (propertyInfo.GetValueOrDefault(data) is { } columnValue)
            {
                whereClause.Append(propertyInfo.Name, " = @", propertyInfo.Name, " AND ");
                parameters.Add(new($"@{propertyInfo.Name}", columnValue));
            }
            else if (!columnAttribute.IgnoreRules.HasFlag(IgnoreRule.SelectIfNull))
                whereClause.Append(propertyMetadata.ColumnName, " IS NULL AND ");
        }

        if (columns.Length == 0)
            throw new InvalidOperationException($"No properties with '{nameof(SqlColumnAttribute)}' found in '{classMetadata.ClassType.Name}'.");

        columns.Length -= 2; // Removes last ", "

        SqlTableAttribute tableAttribute = classMetadata.TableAttribute;
        StringBuilder commandText = new();

        commandText.Append("SELECT ");

        if (distinct)
            commandText.Append("DISTINCT ");

        commandText.Append(columns, " FROM ", classMetadata.TableName);

        if (whereClause.Length > 0)
        {
            whereClause.Length -= 5; // Remove last " AND "
            commandText.Append(" WHERE ", whereClause);
        }

        if (!tableAttribute.GroupBy.IsNullOrWhiteSpace())
            commandText.Append(" GROUP BY ", tableAttribute.GroupBy);

        if (!tableAttribute.Having.IsNullOrWhiteSpace())
            commandText.Append(" HAVING ", tableAttribute.Having);

        if (!tableAttribute.OrderBy.IsNullOrWhiteSpace())
            commandText.Append(" ORDER BY ", tableAttribute.OrderBy);

        AppendSelectPaginationClause(commandText, tableAttribute, offset, maxResults);

        return new(commandText.ToString(), parameters.ToArray());
    }
    #endregion

    #region CreateUpdateCommand
    /// <summary>
    /// Generates a SQL UPDATE command based on the properties of the specified class type <typeparamref name="T"/>.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="data"></param>
    /// <param name="filter"></param>
    /// <returns></returns>
    /// <exception cref="InvalidOperationException"></exception>
    public virtual SqlCommand CreateUpdateCommand<T>(T data, SqlFilter filter = null)
    {
        ClassMetadata classMetadata = ClassMetadataCache.GetClassMetadata(typeof(T));

        StringBuilder setClause = new();
        StringBuilder whereClause = new();
        List<SqlParameter> parameters = new(classMetadata.PropertiesMetadata.Length);

        if (filter is not null)
        {
            whereClause.Append(filter.Text, " AND ");
            parameters.AddRange(filter.Parameters);
        }

        foreach (PropertyMetadata propertyMetadata in classMetadata.PropertiesMetadata)
        {
            PropertyInfo propertyInfo = propertyMetadata.PropertyInfo;
            SqlColumnAttribute columnAttribute = propertyMetadata.ColumnAttribute;

            if (!columnAttribute.Expression.IsNullOrWhiteSpace()
                || columnAttribute.IgnoreRules.HasFlag(IgnoreRule.UpdateAlways))
                continue;

            if (propertyInfo.GetValueOrDefault(data) is { } columnValue)
            {
                if (columnAttribute.IsPrimaryKey)
                    whereClause.Append(propertyMetadata.ColumnName, " = @", propertyInfo.Name, " AND ");
                else
                    setClause.Append(propertyMetadata.ColumnName, " = @", propertyInfo.Name, ", ");

                parameters.Add(new($"@{propertyInfo.Name}", columnValue));
            }
            else if (!columnAttribute.IgnoreRules.HasFlag(IgnoreRule.UpdateIfNull))
                setClause.Append(propertyMetadata.ColumnName, " = NULL, ");
        }

        if (setClause.Length == 0)
            throw new InvalidOperationException($"No properties with '{nameof(SqlColumnAttribute)}' found in '{classMetadata.ClassType.Name}'.");

        if (whereClause.Length == 0)
            throw new InvalidOperationException("No primary key defined and no filter specified for the update operation. This would result in updating all records.");

        setClause.Length -= 2; // Removes last ", "

        StringBuilder commandText = new();
        commandText.Append("UPDATE ", classMetadata.TableName, " SET ", setClause);

        if (whereClause.Length > 0)
        {
            whereClause.Length -= 5; // Remove last " AND "
            commandText.Append(" WHERE ", whereClause);
        }

        return new(commandText.ToString(), parameters.ToArray());
    }
    #endregion

    #region CreateUpsertCommand
    /// <summary>
    /// Generates a SQL UPSERT (UPDATE OR INSERT) command based on the properties of the specified class type <typeparamref name="T"/>.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="data"></param>
    /// <returns></returns>
    /// <exception cref="ArgumentNullException"></exception>
    /// <exception cref="InvalidOperationException"></exception>
    public virtual SqlCommand CreateUpsertCommand<T>(T data)
    {
        if (data is null)
            throw new ArgumentNullException(nameof(data));

        ClassMetadata classMetadata = ClassMetadataCache.GetClassMetadata(typeof(T));

        StringBuilder onClause = new();
        StringBuilder setClause = new();
        StringBuilder insertClause = new();
        StringBuilder valuesClause = new();

        foreach (PropertyMetadata propertyMetadata in classMetadata.PropertiesMetadata)
        {
            PropertyInfo propertyInfo = propertyMetadata.PropertyInfo;
            SqlColumnAttribute columnAttribute = propertyMetadata.ColumnAttribute;

            if (columnAttribute.IgnoreRules.HasFlag(IgnoreRule.UpsertAlways)
                || !columnAttribute.Expression.IsNullOrWhiteSpace()
                || (!propertyInfo.TryGetValue(data, out object columnValue) || columnValue is null)
                && columnAttribute.IgnoreRules.HasFlag(IgnoreRule.UpsertIfNull))
                continue;

            string columnName = propertyMetadata.ColumnName;

            if (columnAttribute.IsPrimaryKey)
                if (columnValue is null)
                    onClause.Append("target.", columnName, " IS NULL AND source.", columnName, " IS NULL AND ");
                else
                    onClause.Append("target.", columnName, " = source.", columnName, " AND ");
            else
                setClause.Append("target.", columnName, " = source.", columnName, ", ");

            insertClause.Append(columnName, ", ");
            valuesClause.Append("source.", columnName, ", ");
        }

        if (onClause.Length == 0)
            throw new InvalidOperationException($"No eligible primary key column found in {classMetadata.ClassType.Name}.");

        if (setClause.Length == 0)
            throw new InvalidOperationException($"No columns to be set found in {classMetadata.ClassType.Name}.");

        onClause.Length -= 5; // Removes last " AND "

        // Removes last ", "
        setClause.Length -= 2;
        insertClause.Length -= 2;
        valuesClause.Length -= 2;

        StringBuilder commandText = new();
        List<SqlParameter> parameters = new(classMetadata.PropertiesMetadata.Length);

        commandText.Append("MERGE INTO ", classMetadata.TableName, " AS target ");
        AppendUpsertSourceClause(data, commandText, parameters, classMetadata.PropertiesMetadata);
        commandText.Append("ON ", onClause, " WHEN MATCHED THEN UPDATE SET ", setClause, " WHEN NOT MATCHED THEN INSERT(",
            insertClause, ") VALUES(", valuesClause, ");");

        return new(commandText.ToString(), parameters.ToArray());
    }
    #endregion

    #endregion

    #region Protected Methods

    #region AppendSelectPaginationClause
    /// <summary>
    /// Inserts pagination clauses into the provided SQL command text.
    /// </summary>
    /// <param name="commandText"></param>
    /// <param name="tableAttribute"></param>
    /// <param name="offset"></param>
    /// <param name="maxResults"></param>
    protected virtual void AppendSelectPaginationClause(StringBuilder commandText, SqlTableAttribute tableAttribute, int offset, int maxResults)
    {
        if (maxResults > 0)
        {
            if (tableAttribute.OrderBy.IsNullOrWhiteSpace())
                commandText.Append(" ORDER BY (SELECT NULL)"); // ORDER BY is required when using OFFSET-FETCH.

            commandText.Append(" OFFSET ", offset, " ROWS FETCH NEXT ", maxResults, " ROWS ONLY");
        }
    }
    #endregion

    #region AppendUpsertSourceClause
    /// <summary>
    /// Appends the USING clause for an UPSERT operation to the provided SQL command text.
    /// </summary>
    /// <typeparam name="T"></typeparam>
    /// <param name="data"></param>
    /// <param name="commandText"></param>
    /// <param name="parameters"></param>
    /// <param name="propertiesMetadata"></param>
    /// <exception cref="InvalidOperationException"></exception>
    protected virtual void AppendUpsertSourceClause<T>(T data, StringBuilder commandText, List<SqlParameter> parameters, PropertyMetadata[] propertiesMetadata)
    {
        StringBuilder columnsText = new();

        foreach (PropertyMetadata propertyMetadata in propertiesMetadata)
        {
            PropertyInfo propertyInfo = propertyMetadata.PropertyInfo;
            SqlColumnAttribute columnAttribute = propertyMetadata.ColumnAttribute;

            if (columnAttribute.IgnoreRules.HasFlag(IgnoreRule.UpsertAlways)
                || !columnAttribute.Expression.IsNullOrWhiteSpace())
                continue;

            if (propertyInfo.GetValueOrDefault(data) is { } columnValue)
            {
                columnsText.Append("@", propertyInfo.Name, " AS ", propertyMetadata.ColumnName, ", ");
                parameters.Add(new($"@{propertyInfo.Name}", columnValue));
            }
            else if (!columnAttribute.IgnoreRules.HasFlag(IgnoreRule.UpsertIfNull))
                columnsText.Append("NULL AS ", propertyMetadata.ColumnName, ", ");
        }

        if (columnsText.Length == 0)
            throw new InvalidOperationException($"No eligible properties with '{nameof(SqlColumnAttribute)}' found in '{typeof(T).Name}'.");

        columnsText.Length -= 2; // Removes last ", "
        commandText.Append("USING (SELECT ", columnsText, ") AS source ");
    }
    #endregion

    #region ValidateSelectPaginationInfo
    /// <summary>
    /// Validates the pagination parameters to ensure they are within acceptable ranges.
    /// </summary>
    /// <param name="offset"></param>
    /// <param name="maxResults"></param>
    /// <exception cref="ArgumentOutOfRangeException"></exception>
    protected virtual void ValidateSelectPaginationInfo(int offset, int maxResults)
    {
        if (offset < 0)
            throw new ArgumentOutOfRangeException(nameof(offset), $"'{nameof(offset)}' must be greater than or equal to zero.");

        if (offset > 0 && maxResults <= 0)
            throw new ArgumentOutOfRangeException(nameof(maxResults), $"When '{nameof(offset)}' is greater than zero, '{nameof(maxResults)}' must be greater than zero.");
    }
    #endregion

    #endregion
}